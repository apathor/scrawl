#!/bin/bash
# scrawl - Quick temporary files.

scrawl() {
    # usage string
    read -r -d '' use <<EOF
USAGE: scrawl [MODE] [OPTIONS]
Quickly make and dump tagged temporary files.
Each entry is identified by an integer and zero or more tags.
IDs are the current Unix time by default but can be any integer.

MODES
  -A [TAG ...]       | add     | Add new entry with given tags.
  -G [TAG ...] INDEX | get     | Output entry at given index of matching entries.
  -L [TAG ...]       | list    | List indexed info of matching entries.
  -T [TAG ...]       | tags    | List all tags in matching entries.

OPTIONS
  -a [UNIXTIME] | after   | Filter entries by IDs after the given unix time.
  -b [UNIXTIME] | before  | Filter entries by IDs before the given unix time.
  -d [UNIXTIME] | day     | Filter entries by ID 12h before and after the given unix time.
  -i INTEGER    | id      | Filter entries or make a new entry with the given ID.
  -r            | reverse | Reverse entry ID sort order.
  -s            | simple  | Output only the file name of matching entries.
  -t TAG_STRING | tag     | Filter entries or make a new entry with the given tag.

EXAMPLES
 # Add entries
  $ scrawl -A foo baz < <(fortune)
  $ curl -sS https://ietf.org | scrawl foo

 # Get entries
  $ scrawl -G -t foo 0
  $ scrawl -Gs foo 1

 # List entries
  $ scrawl -L -t baz
  $ scrawl -L -s foo | parallel grep -l ietf
  $ scrawl -Ls -d \$(date +%s) | xargs rm -v

 # List tags
  $ scrawl -T foo

Mike Lalumiere 2017 - GPLv3
EOF
    # working directory must exist and be writable
    declare sdir="${SCRAWL_DIR:-$HOME/.scrawl}"
    sdir="${sdir%%/}"
    if ! mkdir -p "$sdir" || ! [ -w "$sdir" ]; then
        printf "%s\n" "Could not make or write to directory $sdir!" >&2
        return 1
    fi
    # record the current time
    local now="$(printf "%(%s)T\n")"
    # declare regular expressions
    declare _int='^[0-9]+$'                    # INTEGER
    declare _pos='^[+-]?[0-9]+$'               # +/-INTEGER
    declare _tag='^[a-Z][a-Z0-9]*$'            # TAG
    declare _mine='^[0-9]+(_[a-Z][a-Z0-9]+)*$' # INTEGER(_TAG)*
    # declare some variables
    declare mode exact reverse simple after before given
    declare -a wtags
    # guess the program mode
    if ! [ -t 0 ]; then
        # add an entry when open on stdin
        mode="add"
    elif [[ "${@: -1}" =~ $_int ]]; then
        # get an entry given a numeric last argument
        mode="get"
    elif ! [ -t 1 ] || [ "$#" -gt 0 ]; then
        # list when open on stdout or given some arguments
        mode="list"
    else
        # help the user when run with no arguments or pipes
        mode="help"
    fi
    # accept options
    while getopts ":AGHLTa:b:d:hi:rst:" opt; do
        case "$opt" in
            # modes
            H|h) ## help
                mode="help" ;;
            A)  ## add [ TAG ... ]
                mode="add"  ;;
            G)  ## get INDEX
                mode="get"  ;;
            L)  ## list
                mode="list" ;;
            T)  ## tags
                mode="tags" ;;
            # options
            a) ## future - select entries with IDs after now
                after="$OPTARG"
                if ! [[ "$after" =~ $_int ]]; then
                    printf "After filter be an integer Unix time.\n" >&2
                    return 2
                fi
                ;;
            b) ## past - select entries with IDs before now
                before="$OPTARG"
                if ! [[ "$before" =~ $_int ]]; then
                    printf "Before filter must be an integer Unix time.\n" >&2
                    return 2
                fi
                ;;
            d) ## day - select entries with IDs within today's epoch day
                given="$OPTARG"
                if ! [[ "$given" =~ $_int ]]; then
                    printf "Day filter must be an integer Unix time.\n" >&2
                    return 2
                fi
                after="$(( given - (86400 / 2) ))"
                before="$(( given + (86400 / 2) ))"
                ;;
            i) ## id INTEGER - select entries with given ID
                exact="$OPTARG"
                if ! [[ "$exact" =~ $_int ]]; then
                    printf "Entry ID must be an integer.\n" >&2
                    return 2
                fi
                ;;
            r) ## reverse - reverse sort of entries
                reverse="YES"
                ;;
            s) ## simple - just print the path of selected entries
                simple="YES"
                ;;
            t) ## tag TAG_STRING - select entries with given tag ( multiple accepted )
                if ! [[ "$OPTARG" =~ $_tag ]]; then
                    printf "Invalid tag '%s'.\n" "$OPTARG" >&2
                    return 2
                fi
                wtags+=("$OPTARG")
                ;;
            # optional option arguments
            :)
                case "$OPTARG" in
                    a) # after now
                        after="$now"
                        ;;
                    b) # before now
                        before="$now"
                        ;;
                    d) # day around now
                        after="$(( now - (86400 / 2) ))"
                        before="$(( now + (86400 / 2) ))"
                        ;;
                    *) # unknown
                        printf "Missing required argument for option '%s'!\n%s\n" "$OPTARG" "$use" >&2
                        return 1
                        ;;
                esac
                ;;
            # unexpected
            \?)
                printf "Invalid option '%s'!\n%s\n" "$OPTARG" "$use" >&2
                return 1
                ;;
        esac
    done
    shift $((OPTIND - 1))
    # some modes accept any additional arguments as wtags
    while [ "$#" -gt 0 ]; do
        if ! [[ "$1" =~ $_tag ]]; then break; fi
        wtags+=("$1")
        shift
    done
    # some modes filter existing entries
    declare -a hits
    local len
    if [ "$mode" == "get" ] || [ "$mode" == "list" ] || [ "$mode" == "tags" ]; then
        # consider each file in the working directory
        for file in "$sdir"/*; do
            # parse filename
            local base="${file##*/}"
            # skip files that dont match the format
            if ! [[ "$base" =~ $_mine ]]; then continue; fi
            # parse filename
            IFS='_' read id tags <<< "$base"
            # filter by time selection
            if [ -n "$exact" ]  && [ "$id" != "$exact" ]; then continue; fi
            if [ -n "$after"  ] && [ "$id" -lt "$after"  ]; then continue; fi
            if [ -n "$before" ] && [ "$id" -gt "$before" ]; then continue; fi
            # filter by tag
            local found=0
            for tag in ${tags//_/ }; do
                for wtag in "${wtags[@]}"; do
                    if [ "${wtag,,}" == "${tag,,}" ]; then found=1; fi
                done
            done
            if [ "${#wtags[@]}" -ne 0 ] && [ "$found" -ne 1 ]; then continue 2; fi
            # push matching files
            hits+=("$file")
        done
        # record number of hits
        len="${#hits[@]}"
        # maybe reverse order of results
        if [ -z "$reverse" ]; then
            declare -a revs
            for ((x="$len" - 1; x >= 0; x--)); do revs+=("${hits[$x]}"); done
            hits=("${revs[@]}")
        fi
    fi
    # select program mode
    case "$mode" in
        # help - write some usage text
        help)
            printf "%s\n" "$use"
            return 0
            ;;
        # add - make a new entry
        add)
            # generate file name
            path="${sdir}/${id:-$now}"
            if [ "${#wtags[@]}" -gt 0 ]; then
                path+="$(printf '_%s' "${wtags[@]}")";
            fi
            path="${path,,}"
            # nothing on stdin?
            if [ -t 0 ]; then
                # edit interactively
                eval "${EDITOR:-/bin/nano} $path"
            else
                # validate input file
                if [ -d /dev/stdin ]; then
                    printf "Input is a directory?\n" >&2
                    return 3
                fi
                # write input out to entry
                while read -r line; do printf "%s\n" "$line"; done > "$path"
            fi
            # write out file path
            if [ -f "$path" ]; then printf "%s\n" "$path"; fi
            ;;
        # get - show file with given index
        get)
            # maybe nothing was found
            if [ "${len:-0}" -lt 1 ]; then
                printf "No entries found!\n" >&2
                return 2
            fi
            # accept integer index
            declare pick="${1:-0}"
            if ! [[ "$pick" =~ $_pos ]]; then
                printf "Get index must be +/- integer.\n" >&2
                return 2
            fi
            if [ "${pick#-}" -gt "$(( len - 1 ))" ]; then
                printf "Max index is %s!\n" "$(( len - 1 ))" >&2
                return 2
            fi
            # write out file path or its contents
            hit="${hits[$pick]}"
            if [ -n "$simple" ]; then
                printf "%s\n" "$hit"
            else
                file="${hit##*/}"
                IFS='_' read id tags <<< "$file"
                printf "%s %(%F %T)T %s\n" "$id" "$id" "${tags//_/,}" >&2
                while read -r line; do printf "%s\n" "$line"; done < "${hits[$pick]}"
            fi
            ;;
        # list - list matching entries
        list)
            # maybe nothing was found
            if [ "${len:-0}" -lt 1 ]; then
                printf "No entries found!\n" >&2
                return 2
            fi
            declare index="0"
            for hit in "${hits[@]}"; do
                if [ -n "$simple" ]; then
                    # simple format: FILENAME
                    printf "%s\n" "$hit"
                else
                    # default format: INDEX ID TIMESTAMP PREVIEW
                    declare len info
                    # parse file name for normal output
                    file="${hit##*/}"
                    IFS='_' read id tags <<< "$file"
                    # render entry info
                    stamp="$(printf '%(%F %T)T' "$id")"
                    printf "% 3d %d %s %s %s %s\n" \
                           "$index" "$id" "$stamp" "${tags//_/,}"
                fi
                # increment index
                let index++;
            done
            ;;
        # tags - list tags in matching entries
        tags)
            declare -A all
            for hit in "${hits[@]}"; do
                IFS='_' read -r -a t <<< "$hit"
                for t in "${t[@]:1}"; do all["${t,,}"]+=1; done
            done
            printf "%s\n" "${!all[@]}" | sort
            ;;

        *) # something else?
            printf "Invalid mode '%s'. How did that happen?" "$mode" >&2
            return 5
            ;;
    esac
    return 0;
}
# run it unless sourced
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then scrawl "$@"; fi
