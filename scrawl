#!/bin/bash
# scrawl - Tagged temporary files.

scrawl() {
    # usage
    read -r -d '' use <<EOF
USAGE: scrawl [MODE] [OPTIONS]
Create and manipulate tagged temporary files.
Each entry is identified by an integer and zero or more tags.
IDs are the current epoch time by default but can be any integer.

MODES
  -A [TAG ...]       | add     | Add new entry with given tags.
  -D [TAG ...] INDEX | delete  | Delete entry at given index of matching entries.
  -E [TAG ...] INDEX | edit    | Edit entry at given index of matching entries.
  -G [TAG ...] INDEX | get     | Output entry at given index of matching entries.
  -L [TAG ...]       | list    | List indexed info of matching entries.
  -T [TAG ...]       | tags    | List all tags in matching entries.

OPTIONS
  -a [UNIXTIME] | after   | Filter entries by IDs after the given unix time.
  -b [UNIXTIME] | before  | Filter entries by IDs before the given unix time.
  -d [UNIXTIME] | day     | Filter entries by ID 12h before and after the given unix time.
  -e            | encrypt | Encrypt a file with PGP.
  -i INTEGER    | id      | Filter entries or make a new entry with the given ID.
  -r            | reverse | Reverse entry ID sort order.
  -s            | simple  | Output only the file name of matching entries.
  -t TAG_STRING | tag     | Filter entries or make a new entry with the given tag.

EXAMPLES
 # Add entries
  $ scrawl -A foo baz < <(fortune)
  $ curl -sS https://ietf.org | scrawl foo

 # Get entries
  $ scrawl -G -t foo 0
  $ scrawl -Gs foo 1

 # List entries
  $ scrawl -L -t baz
  $ scrawl -L -s foo | parallel grep -l ietf
  $ scrawl -Ls -d 1572047858 | xargs rm -v

 # List tags
  $ scrawl -T foo
EOF
    # working directory must exist and be writable
    declare sdir="${SCRAWL_DIR:-$HOME/.scrawl}"
    sdir="${sdir%%/}"
    if ! mkdir -p "$sdir" || ! [ -w "$sdir" ]; then
        printf "%s\n" "Could not make or write to directory $sdir!" >&2
        return 1
    fi
    # record the current time
    local now
    now=$(printf "%(%s)T\n")
    # local
    local editor="${EDITOR:-/usr/bin/sensible-editor}"
    # regular expressions
    local _int='^[0-9]+$'                                   # INTEGER
    local _pos='^[+-]?[0-9]+$'                              # +/-INTEGER
    local _tag='^[a-Z][a-Z0-9]*$'                           # TAG
    local _mine='^[0-9]+(_[a-Z][a-Z0-9]+)*([.][a-Z0-9]+)*$' # INTEGER(_TAG)*
    # declare some variables
    local mode exact reverse simple after before given encrypt
    declare -a wtags
    # guess the program mode
    if ! [ -t 0 ]; then
        # add an entry when open on stdin
        mode="add"
    elif [[ "${@: -1}" =~ $_int ]]; then
        # get an entry given a numeric last argument
        mode="get"
    elif ! [ -t 1 ] || [ "$#" -gt 0 ]; then
        # list when open on stdout or given some arguments
        mode="list"
    else
        # help the user when run with no arguments or pipes
        mode="help"
    fi
    # accept options
    local opt OPTIND OPTARG
    while getopts ":ADEGHLTa:b:d:ehi:rst:" opt; do
        case "$opt" in
            # modes
            H|h) mode="help"   ;;
            A)   mode="add"    ;;
            D)   mode="delete" ;;
            E)   mode="edit"   ;;
            G)   mode="get"    ;;
            L)   mode="list"   ;;
            T)   mode="tags"   ;;
            # options
            a) ## future - select entries with IDs after now
                after="$OPTARG"
                if ! [[ "$after" =~ $_int ]]; then
                    printf "After filter be an integer epoch time.\n" >&2
                    return 2
                fi
                ;;
            b) ## past - select entries with IDs before now
                before="$OPTARG"
                if ! [[ "$before" =~ $_int ]]; then
                    printf "Before filter must be an integer epoch time.\n" >&2
                    return 2
                fi
                ;;
            d) ## day - select entries with IDs within today's epoch day
                given="$OPTARG"
                if ! [[ "$given" =~ $_int ]]; then
                    printf "Day filter must be an integer epoch time.\n" >&2
                    return 2
                fi
                after="$(( given - (86400 / 2) ))"
                before="$(( given + (86400 / 2) ))"
                ;;
            e) ## encrypt
                encrypt="YES"
                ;;
            i) ## id INTEGER - select entries with given ID
                exact="$OPTARG"
                if ! [[ "$exact" =~ $_int ]]; then
                    printf "Entry ID must be an integer.\n" >&2
                    return 2
                fi
                ;;
            r) ## reverse - reverse sort of entries
                reverse="YES"
                ;;
            s) ## simple - just print the path of selected entries
                simple="YES"
                ;;
            t) ## tag TAG_STRING - select entries with given tag ( multiple accepted )
                if ! [[ "$OPTARG" =~ $_tag ]]; then
                    printf "Invalid tag '%s'.\n" "$OPTARG" >&2
                    return 2
                fi
                wtags+=("$OPTARG")
                ;;
            :) # some options have optional arguments
                case "$OPTARG" in
                    a) # after now
                        after="$now"
                        ;;
                    b) # before now
                        before="$now"
                        ;;
                    d) # day around now
                        after="$(( now - (86400 / 2) ))"
                        before="$(( now + (86400 / 2) ))"
                        ;;
                    *) # unknown
                        printf "Missing required argument for option '%s'!\n%s\n" "$OPTARG" "$use" >&2
                        return 1
                        ;;
                esac
                ;;
            # an unexpected option was provided
            \?)
                printf "Invalid option '%s'!\n%s\n" "$OPTARG" "$use" >&2
                return 1
                ;;
        esac
    done
    shift $((OPTIND - 1))
    # some modes accept any additional arguments as wtags
    while [ "$#" -gt 0 ]; do
        if ! [[ "$1" =~ $_tag ]]; then break; fi
        wtags+=("$1")
        shift
    done
    # some modes filter existing entries
    declare -a hits
    local len
    case "$mode" in get|edit|delete|list|tags)
        # consider each file in the working directory
        for file in "$sdir"/*; do
            # parse filename
            local base="${file##*/}"
            # skip files that dont match the format
            if ! [[ "$base" =~ $_mine ]]; then continue; fi
            # parse filename
            IFS='_' read -r id tags <<< "$base"
            # filter by time selection
            if [ -n "$exact" ]  && [ "$id" != "$exact" ];   then continue; fi
            if [ -n "$after"  ] && [ "$id" -lt "$after"  ]; then continue; fi
            if [ -n "$before" ] && [ "$id" -gt "$before" ]; then continue; fi
            # filter by tag
            local found=0
            for tag in ${tags//_/ }; do
                for wtag in "${wtags[@]}"; do
                    if [ "${wtag,,}" == "${tag,,}" ]; then found=1; fi
                done
            done
            if [ "${#wtags[@]}" -ne 0 ] && [ "$found" -ne 1 ]; then continue 2; fi
            # push matching files
            hits+=("$file")
        done
        # record number of hits
        len="${#hits[@]}"
        # maybe reverse order of results
        if [ -z "$reverse" ]; then
            declare -a revs
            for ((x="$len" - 1; x >= 0; x--)); do revs+=("${hits[$x]}"); done
            hits=("${revs[@]}")
        fi
        ;;
    esac
    # select program mode
    local hit name path tmp
    case "$mode" in
        # help - write some usage text
        help)
            printf "%s\n" "$use"
            return 0
            ;;
        # add - make a new entry
        add)
            # generate file names
            name="${id:-$now}"
            if [ "${#wtags[@]}" -gt 0 ]; then
                name+="$(printf '_%s' "${wtags[@],,}")";
            fi
            path="$sdir/$name"
            tmp="/dev/shm/$name"
            # nothing on stdin?
            if [ -t 0 ]; then
                # edit interactively if possible
                if ! "$editor" "$tmp"; then return 3; fi
            else
                # write input out to entry
                printf "%s\n" "$(< /dev/stdin)" > "$tmp"
            fi
            # ensure that a file was made
            if ! [ -f "$tmp" ]; then return 3; fi
            # create the new entry
            if [ -n "$encrypt" ]; then
                # encrypted
                path="$path.gpg"
                gpg -e -q -a < "$tmp" > "$path"
            else
                # plaintext
                printf "%s\n" "$(< "$tmp")" > "$path"
            fi
            # clean up
            rm "$tmp"
            # write out file path
            if [ -f "$path" ]; then printf "%s\n" "$path"; fi
            ;;
        # get/edit/delete - manipulate a single entry
        get|edit|delete)
            # maybe nothing was found
            if [ "${len:-0}" -lt 1 ]; then
                printf "No entries found!\n" >&2
                return 2
            fi
            # accept an integer index
            declare pick="${1:-0}"
            if ! [[ "$pick" =~ $_pos ]]; then
                printf "Get index must be +/- integer.\n" >&2
                return 2
            fi
            # absolute index must be between 0 and the number of entries found
            if [ "${pick#-}" -gt "$(( len - 1 ))" ]; then
                printf "Max index is %s!\n" "$(( len - 1 ))" >&2
                return 2
            fi
            # lookup file by index
            hit="${hits[$pick]}"
            # switch on mode
            case "$mode" in
                delete)
                    # delete that file
                    rm -i -v "$hit"
                    ;;
                edit)
                    # optionally decrypt the entry
                    tmp="$hit"
                    if [[ "$hit" == *.gpg ]]; then
                        encrypt="yes"
                        tmp="/dev/shm/${hit##*/}"
                        tmp="${tmp%%.gpg}"
                        gpg -d -q < "$hit" > "$tmp"
                    fi
                    # edit the entry
                    if ! "$editor" "$tmp"; then return 3; fi
                    # maybe re-encrypt
                    if [ -n "$encrypt" ]; then
                        gpg -e -q -a < "$tmp" > "${hit%%.gpg}.gpg"
                        rm "$tmp"
                    fi
                    # write out file path
                    printf "%s\n" "$hit"
                    ;;
                get)
                    # for simple output just write the path
                    if [ -n "$simple" ]; then
                        printf "%s\n" "$hit"
                        return
                    fi
                    # write file contents, decrypting if necessary
                    if [[ "$hit" == *.gpg ]]; then
                        gpg -q -d < "$hit"
                    else
                        printf "%s\n" "$(< "$hit")"
                    fi
                    ;;
            esac
            ;;
        # list - list matching entries
        list)
            # maybe nothing was found
            if [ "${len:-0}" -lt 1 ]; then
                printf "No entries found!\n" >&2
                return 2
            fi
            # print each entry
            local index=0
            for hit in "${hits[@]}"; do
                if [ -n "$simple" ]; then
                    # simple format: FILENAME
                    printf "%s\n" "$hit"
                else
                    # split file for attributes
                    name="${hit##*/}"
                    IFS='_' read -r id tags <<< "${name%%.*}"
                    # render entry info - INDEX ID TIMESTAMP PREVIEW
                    printf "% 3d %s %(%F %T)T %s %s %s\n" \
                           "$index" "$id" "$id" "${tags//_/,}"
                fi
                let index++;
            done
            ;;
        # tags - list tags in matching entries
        tags)
            declare -A all
            for hit in "${hits[@]}"; do
                IFS='_' read -r -a t <<< "$hit"
                for t in "${t[@]:1}"; do all["${t,,}"]+=1; done
            done
            printf "%s\n" "${!all[@]}" | sort
            ;;
    esac
    return 0;
}

# _scrawl - command completion for scrawl
_scrawl() {
    # scrawl has some modes
    declare -a modes
    modes=(-{A,D,G,L,T})
    # scrawl has some options
    declare -A opts
    for opt in -{a,b,d,e,h,i,r,s,t}; do opts["$opt"]=0; done
    # scan all previous words
    local mode=""
    for word in "${COMP_WORDS[@]}"; do
        case "$word" in
            -A|-D|-G|-L|-T) mode="$word" ;;
            -a|-b|-d|-e|-h|-i|-r|-s) unset opts["$word"] ;;
        esac
    done
    local cur="${COMP_WORDS[COMP_CWORD]}"
    # first maybe consider the previous word
    if [[ "$COMP_CWORD" -gt 1 ]]; then
        case "${COMP_WORDS[COMP_CWORD-1]}" in
            -a|-b|-d)
                # for date options try to be helpful
                if [ -z "$cur" ]; then COMPREPLY=("\$(date +%s)"); fi
                return
                ;;
            -i) # for ID option
                declare -a ids
                while read -r _ i _; do ids+=("$i"); done < <(scrawl -L)
                COMPREPLY=($(compgen -W "${ids[*]}" -- "$cur"))
                return
                ;;
            -t) # for tag option complete on all tags
                mapfile tags < <(scrawl -T)
                COMPREPLY=($(compgen -W "${tags[*]} " -- "$cur"))
                return
                ;;
        esac
    fi
    # figure possible next words
    declare -a next
    # modes if one has not been given already
    if [ -z "$mode" ]; then
        next+=("${modes[@]}")
    fi
    # options
    if :; then # unless past option processing?
        next+=("${!opts[@]}")
    fi
    # complete on next tokens
    COMPREPLY=($(compgen -S' ' -W "${next[*]}" -- "$cur"))
}
complete -F _scrawl scrawl

# run it unless sourced
if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then scrawl "$@"; fi
